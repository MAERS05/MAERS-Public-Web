# MAERS 架构决策记录 (Architecture Decision Records)

本文档记录了 MAERS 项目当前生效的核心架构决策。

---

## 📋 目录 (Table of Contents)

- [ADR-001: 无框架架构](#adr-001-无框架架构)
- [ADR-002: SQLite 数据库](#adr-002-sqlite-数据库)
- [ADR-003: 前后端混合架构](#adr-003-前后端混合架构)
- [ADR-004: 模块化目录结构](#adr-004-模块化目录结构)
- [ADR-005: ES6 模块化](#adr-005-es6-模块化)
- [ADR-006: 关键路径同步渲染](#adr-006-关键路径同步渲染)
- [ADR-007: CSS 分层架构](#adr-007-css-分层架构)
- [ADR-008: 图片多级存储](#adr-008-图片多级存储)
- [ADR-009: 统一数据交换格式为 JSON](#adr-009-统一数据交换格式为-json)
- [ADR-010: 全局命名空间策略](#adr-010-全局命名空间策略-global-namespace-policy)
- [ADR-011: 跨模块数据持久化与交互策略](#adr-011-跨模块数据持久化与交互策略-dual-persistence-strategy)
- [ADR-012: 轻量级全局配置中心](#adr-012-轻量级全局配置中心-global-configuration)
- [ADR-013: 事件驱动 UI 架构 (音乐模块)](#adr-013-事件驱动-ui-架构-event-driven-ui)

---

## ADR-001: 无框架架构

**状态**: ✅ 已采纳  
**类型**: 基础架构

### 决策
采用原生 HTML5 / CSS3 / JavaScript，不引入 React、Vue、Angular 等任何现代前端框架。

### 理由
1.  **长期维护性**: 标准 Web 技术具有极强的生命周期，不受框架版本迭代（如 Vue2 到 Vue3 的破坏性升级）影响。
2.  **极致轻量**: 无需 `node_modules` 依赖黑洞，项目克隆即运行，体积极小。
3.  **完全掌控**: 开发者对每一行代码拥有绝对控制权，便于深度定制和性能调优。

---

## ADR-002: SQLite 数据库

**状态**: ✅ 已采纳  
**类型**: 数据存储

### 决策
使用 SQLite 作为内容管理的持久化存储，配合 Python 后端使用。

### 理由
1.  **零配置**: 无需安装和维护独立的数据库服务（如 MySQL）。
2.  **便携性**: 整个数据库是一个单文件 (`.db`)，备份和迁移只需复制文件。
3.  **适用性**: 对于个人博客系统，SQLite 的性能完全满足需求。

---

## ADR-003: 前后端混合架构

**状态**: ✅ 已采纳  
**类型**: 系统架构

### 决策
采用 "静态优先 + 动态管理" 的混合模式。
-   **访客端 (Viewer)**: 纯静态架构。通过 Fetch API 读取静态 JSON 数据文件渲染页面。
-   **管理端 (Admin)**: 动态架构。在本地 Python 环境下运行，提供 API 接口进行数据读写和文件操作。

### 理由
兼顾了静态网站的优势（部署简单、访问快、安全性高）和动态网站的灵活性（内容管理便利）。

---

## ADR-004: 模块化目录结构

**状态**: ✅ 已采纳  
**类型**: 代码组织

### 决策
按业务模块（Feature-based）而非文件类型（Type-based）组织代码。
-   **Structure**: `custom/<module_name>/[admin|viewer]/`
-   **Example**: `custom/cms/viewer/cms-view.module.js`

### 理由
提高代码的高内聚、低耦合。修改特定功能时，相关的所有资源（JS/CSS）都在同一个文件夹下。

---

## ADR-005: ES6 模块化

**状态**: ✅ 已采纳  
**类型**: 代码规范 / 2026-02-01 更新

### 决策
全面采用 ECMAScript Modules (ESM) 标准。
-   使用 `import` / `export` 语法。
-   文件后缀统一为 `.module.js`。
-   HTML 中使用 `<script type="module">`。

### 理由
1.  **标准化**: 浏览器原生支持的模块系统，无需 Webpack 等构建工具。
2.  **作用域隔离**: 彻底解决 IIFE 和全局命名空间污染问题。
3.  **依赖清晰**: 静态分析工具可以解析依赖图谱。

---

## ADR-006: 关键路径同步渲染 (Flash Guard)

**状态**: ✅ 已采纳  
**类型**: 性能优化 / 2026-02-01 更新

### 决策
将防闪烁逻辑 (`flash-guard.js`) 排除在 ES6 模块化之外，保持为**同步阻塞脚本**。
-   在 HTML `<head>` 顶部通过 `<script src="...">` 引用。
-   **禁止**使用 `type="module"` 或 `defer/async`。

### 理由
**关键渲染路径 (Critical Rendering Path)** 要求。
ES6 模块默认延迟执行，会导致页面先渲染（白屏/亮色）再执行脚本（切换深色），造成严重闪烁 (FOUC)。为了用户体验，必须牺牲并发加载，强制阻塞解析以注入初始样式。

---

## ADR-007: CSS 分层架构

**状态**: ✅ 已采纳  
**类型**: 样式管理

### 决策
将样式分解为三层：
1.  **Base**: `cms-base.css` (布局结构)
2.  **Theme**: `cms-theme-default.css`, `literature.css` (视觉主题)
3.  **Module**: 组件级样式

### 理由
解决样式覆盖 (`!important`) 泛滥问题，实现主题的灵活切换和按需加载。

---

## ADR-008: 图片多级存储

**状态**: ✅ 已采纳  
**类型**: 资源优化

### 决策
上传图片同时保留三种格式：
1.  **原图**: 原始上传文件 (Backup/Download)
2.  **预览图**: 大尺寸 AVIF (Lightbox)
3.  **缩略图**: 小尺寸 WebP (Gallery Grid)

### 理由
在保证画质的前提下，最大化加载速度并节省带宽。

---

## ADR-009: 统一数据交换格式为 JSON

**状态**: ✅ 已采纳  
**类型**: 数据交换规范 / 2026-02-01 更新

### 决策
后端服务（`_studio`）生成的静态数据文件统一为标准 JSON 格式（`.json`），不再生成包含 JavaScript 变量赋值的脚本文件（`.js`）。前端通过 Fetch API 异步加载这些数据。

### 理由
1.  **标准化**: JSON 是前后端交换数据的通用标准，独立于编程语言。
2.  **安全性**: 避免在全局作用域污染变量（如 `window.galleryData`）。
3.  **兼容性**: 配合 ES6 Module 的异步加载特性，Fetch JSON 比加载同步 Script 标签更灵活且符合现代 Web 标准。
4.  **一致性**: 解决了前端请求 JSON 但后端生成 JS 导致的 404 或数据不更新问题。

### 替代方案
*   *JSONP / JS 赋值*: 虽然跨域方便且加载快，但污染全局命名空间，且不符合 ES6 模块化隔离的理念。
*   *动态 API*: 对于本项目的“静态生成+动态管理”混合架构，完全动态 API 会丧失纯静态部署的能力。

---

## ADR-010: 全局命名空间策略 (Global Namespace Policy)

**状态**: ✅ 已采纳 / 2026-02-02 新增
**类型**: 代码规范 / 架构约束

### 决策
1.  **Strict Mode (严禁)**: 任何**业务逻辑**模块（如 Music Player, CMS Controller, Album Renderer）**严禁**挂载到 `window.MAERS` 或其他全局变量。
### 允许列表 (Allowlist) 与保留理由
经过深度评估，我们仅保留了以下 3 个**横切关注点 (Cross-Cutting Concerns)** 的基础设施服务驻留全局。除此之外，严禁挂载。

| 变量名 | 类别 | 保留理由 (Rationale for Retention) |
| :--- | :--- | :--- |
| **`window.MAERS.Toast`** | UI Infrastructure | **全局通知服务**。<br>Toast 需要在任意深度的函数栈中被调用（如 API 报错、验证失败）。将其作为全局单例，避免了在成百上千个函数中反复透传 Toast 对象 (Avoids Prop Drilling)。 |
| **`window.MAERS.Theme`** | UI State | **主题状态管理**。<br>主题（深色/浅色、缩放）是单一事实来源 (Single Source of Truth)，且不依赖于具体业务逻辑。让所有 UI 组件能直接读取当前主题状态是最高效的实现。 |
| **`window.MAERS.ModuleConfig`** | Static Config | **静态配置中心**。<br>提供跨模块的静态元数据（如图标、标题）。它是无状态的常量集合，类似环境变量，允许全局访问以实现“配置驱动开发”。 |

### 架构获益
1.  **解耦**: 防止业务模块间通过全局变量进行隐式通信（"Spooky action at a distance"）。
2.  **工程平衡**: 在纯原生 JS 环境下（无 React Context / Vue Provide），这是处理横切关注点成本收益比最高的方案。

### 历史变更
*   **2026-02-02 20:44**: 移除了 `window.MAERS.CMS.Editor` 桥接接口。Literature 模块改为通过 ES6 import 直接导入 Editor，彻底消除了"向后兼容"的全局挂载。

---

## ADR-011: 跨模块数据持久化与交互策略 (Dual Persistence Strategy)

**状态**: ✅ 已采纳 / 2026-02-02 更新
**类型**: 数据一致性与交互体验

### 背景
系统包含三大核心模块：CMS (Literature/Notes)、Photos (Album)、Music。它们虽然共享同一套 UI 组件（如 `admin-core.js` 的 `BatchItemManager`），但底层的数据持久化逻辑截然不同。这导致了早期出现交互行为不一致的问题（如“新建后取消”导致数据在前端回滚）。

### 决策

#### 1. 双重持久化模式 (Dual Strategy)
系统根据模块特性，有意保留两种不同的数据管理模式：

*   **Server-First 模式 (CMS 模块)**
    *   **适用场景**: `Literature`, `Notes` (文件管理)。
    *   **机制**: **文件系统直接映射**。创建/删除/重命名操作通过 POST 请求直接作用于后端硬盘（`fs.mkdir`, `fs.rename`）。
    *   **特性**: 
        *   **立即生效 (Immediate Write)**: 操作即持久化，无法像数据库事务一样回滚。
        *   **依赖后端**: 必须在 Node/Python 服务运行时才能写入，静态环境下只能只读。
        *   **数据源**: `*-tree.json` 只是文件系统的索引缓存。

*   **Client-First 模式 (Music / Photos 模块)**
    *   **适用场景**: `Music` (元数据), `Photos` (排序/分组)。
    *   **机制**: **JSON 数据库 (JSON Database)**。前端维护一个庞大的 JSON 对象，所有的添加/排序/删除本质上都是 JS 数组操作。
    *   **特性**:
        *   **批量提交 (Batch Commit)**: 操作只在前端暂存，点击“保存”按钮后才全量覆写整个 JSON 文件。
        *   **静态友好**: 读取非常容易，适合纯静态部署的数据展示。

#### 2. 交互一致性适配 (UI Shim)
为了在 UI 层面上统一这两种模式的体验（都使用 `BatchItemManager` 提供“选择/排序/取消”功能），我们实施了以下适配策略：

*   **强制快照同步 (Force Snapshot Sync)**:
    在 **CMS 模块**中，当执行“创建文件”这种立即生效的操作后，**必须强制通过 `refreshView(true)` 重新拉取后端数据，并显式更新 `BatchItemManager` 的快照 (Snapshot)**。
    *   **原因**: 如果不更新快照，前端会认为“原始状态”是创建文件之前的状态。当用户点击“取消修改”时，Manager 会错误地回滚到旧状态，导致新创建的文件在视图中消失（虽然硬盘上还在）。

*   **自动清洗脏数据 (Auto-Sanitization)**:
    在 **Client-First 模式**的保存逻辑中（如 `saveData`），通过 `JSON.parse(JSON.stringify(..., replacer))` 自动过滤掉所有以 `_` 开头的运行时临时字段（如 `_searchStr`, `_deleted`）。
    *   **原因**: 防止前端的临时状态污染持久化的 JSON 文件。

#### 3. 安全与 GitOps 部署
本架构天然支持 GitOps 安全模型：
*   **线上环境 (Production)**: 通常部署在 GitHub Pages / Vercel 等纯静态托管。
    *   **安全性**: 由于后端没有处理 POST 请求的能力（纯静态文件服务），访客即使调用 API 也无法篡改数据。数据是**只读**的。
*   **本地环境 (Local Admin)**: 启动 Python/Node 服务。
    *   **可写性**: 服务端脚本拥有文件写入权限，管理者修改内容后，通过 Git 提交代码变更，自动触发线上的重新部署。

### 结论
*   **统一体验**: 无论底层是操作文件系统还是操作 JSON，用户都享有一致的“所见即所得”和“支持撤销（部分场景）”的体验。
*   **最高安全**: 彻底杜绝了线上被黑客篡改数据的可能性（因为根本没有数据库服务端口开放）。

---

## ADR-012: 轻量级全局配置中心 (Global Configuration)

**状态**: ✅ 已采纳 / 2026-02-03 新增
**类型**: 运维优化

### 决策
引入 `custom/config.js` 作为全局配置入口，挂载于 `window.MAERS.Config`。
该文件在 HTML `<head>` 中**紧接** `flash-guard.js` 之后、所有业务模块之前加载。

### 理由
1.  **环境配置解耦**: 解决了将 API 地址（如 `localhost:8000`）硬编码在业务逻辑（如 `music-ui.module.js`）中的问题，允许在不同部署环境（本地通过 File 协议预览、本地 Python Server、线上静态站）下轻松切换配置。
2.  **非侵入性**: 与 ES6 模块解耦。配置通过全局对象暴露，业务模块只需进行可空检查 (`window.MAERS?.Config?.API_BASE`) 即可使用，无需复杂的注入流程。

---

## ADR-013: 事件驱动 UI 架构 (Event-Driven UI)

**状态**: ✅ 已采纳 / 2026-02-03 新增 (Music 模块试点)
**类型**: 性能优化

### 决策
在核心业务对象（如 `Player`）中实现简单的 Pub/Sub 事件系统 (`on/emit`)，替代原有的轮询 (`setInterval`) 机制来驱动 UI 状态更新。
*   **Before**: `setInterval(() => checkState(), 500)` —— 空闲时浪费 CPU，响应有延迟。
*   **After**: `Player.emit('stateChange')` -> `UI.update()` —— 零延迟响应，零空闲开销。

### 理由
1.  **性能**: 消除无效的 CPU 周期，特别适合长期运行的后台页面（如音乐播放器）。
2.  **响应性**: 用户操作（点击播放）与 UI 反馈（按钮变化）完全同步，提升用户体验。
3.  **解耦**: 状态持有者 (`Player`) 不需要知道谁在关注它，只需广播事件。
