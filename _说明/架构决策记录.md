# MAERS 架构决策记录 (Architecture Decision Records)

本文档记录了 MAERS 项目当前生效的核心架构决策。

---

## 📋 目录 (Table of Contents)

- [ADR-001: 无框架架构 (No Framework Architecture)](#adr-001-无框架架构)
- [ADR-002: SQLite 数据库 (SQLite Database)](#adr-002-sqlite-数据库)
- [ADR-003: 前后端混合架构 (Hybrid Architecture)](#adr-003-前后端混合架构)
- [ADR-004: 模块化目录结构 (Modular Structure)](#adr-004-模块化目录结构)
- [ADR-005: ES6 模块化 (ES6 Modules)](#adr-005-es6-模块化)
- [ADR-006: 关键路径同步渲染](#adr-006-关键路径同步渲染-flash-guard)
- [ADR-007: CSS 分层架构 (CSS Layering)](#adr-007-css-分层架构)
- [ADR-008: 图片多级存储 (Multi-level Image Storage)](#adr-008-图片多级存储)
- [ADR-009: 统一数据交换格式为 JSON (Unified Data Format)](#adr-009-统一数据交换格式为-json)
- [ADR-010: 全局命名空间策略 (Global Namespace Policy)](#adr-010-全局命名空间策略-global-namespace-policy)
- [ADR-011: 跨模块数据持久化与交互策略 (Dual Persistence Strategy)](#adr-011-跨模块数据持久化与交互策略-dual-persistence-strategy)
- [ADR-012: 轻量级全局配置中心 (Global Configuration)](#adr-012-轻量级全局配置中心-global-configuration)
- [ADR-013: 事件驱动 UI 架构 (音乐模块)](#adr-013-事件驱动-ui-架构-event-driven-ui)
- [ADR-014: 自动化缓存更新策略 (Service Worker)](#adr-014-自动化缓存更新策略-service-worker)
- [ADR-015: 智能上下文导航 (Smart Context Navigation)](#adr-015-智能上下文导航-smart-context-navigation)
- [ADR-016: 乐观 UI 删除 (Optimistic UI Deletion)](#adr-016-乐观-ui-删除-optimistic-ui-deletion)
- [ADR-017: 移动端极致性能降级](#adr-017-移动端极致性能降级-mobile-extreme-performance-degradation)
- [ADR-018: 统一 SVG 图标体系](#adr-018-统一-svg-图标体系-unified-svg-icon-system)
- [ADR-019: 核心主题与脚本统一](#adr-019-核心主题与脚本统一-theme-unification)
- [ADR-020: 交互式身份验证物理删除](#adr-020-交互式身份验证物理删除-secure-deletion-confirmation)
- [ADR-021: Studio Engine 标准化双语日志回显](#adr-021-studio-engine-标准化双语日志回显-standardized-logging)
- [ADR-022: 模块微服务化重构与职责隔离](#adr-022-模块微服务化重构与职责隔离-micro-modular-refactoring)
- [ADR-023: 管理端物理操作反馈增强](#adr-023-管理端物理操作反馈增强-associated-feedback)
- [ADR-024: 中央保存调度架构 (Centralized Save Coordination)](#adr-024-中央保存调度架构-centralized-save-coordination)
- [ADR-025: 稳定随机化离散流动布局 (Stable Randomized Flow Layout)](#adr-025-稳定随机化离散流动布局-stable-randomized-flow-layout)
- [ADR-026: 客户端模板引擎 (Client-side Templating)](#adr-026-客户端模板引擎-client-side-templating)
- [ADR-027: 显式命名空间初始化 (Explicit Namespace Initialization)](#adr-027-显式命名空间初始化-explicit-namespace-initialization)
- [ADR-028: 文件驱动内容存储 (File-based Content Storage)](#adr-028-文件驱动内容存储-file-based-content-storage)
- [ADR-029: JSON 驱动标签配置 (JSON-based Tag Configuration Storage)](#adr-029-json-驱动标签配置)
- [ADR-030: 标准浏览器级懒加载 (Standard Browser-level Lazy Loading)](#adr-030-标准浏览器级懒加载)
- [ADR-031: 原子化通知系统 (Atomic Notification System)](#adr-031-原子化通知系统)
- [ADR-032: 标签配置命名规范 (Tag Configuration Naming Convention)](#adr-032-标签配置命名规范)

---

## ADR-001: 无框架架构 (No Framework Architecture)

**状态**: ✅ 已采纳  
**类型**: 基础架构

### 决策
采用原生 HTML5 / CSS3 / JavaScript，不引入 React、Vue、Angular 等任何现代前端框架。

### 理由
1.  **长期维护性**: 标准 Web 技术具有极强的生命周期，不受框架版本迭代（如 Vue2 到 Vue3 的破坏性升级）影响。
2.  **极致轻量**: 无需 `node_modules` 依赖黑洞，项目克隆即运行，体积极小。
3.  **完全掌控**: 开发者对每一行代码拥有绝对控制权，便于深度定制和性能调优。

---

## ADR-002: SQLite 数据库 (SQLite Database)

**状态**: ✅ 已采纳  
**类型**: 数据存储

### 决策
使用 SQLite 作为内容管理的持久化存储，配合 Python 后端使用。

### 理由
1.  **零配置**: 无需安装和维护独立的数据库服务（如 MySQL）。
2.  **便携性**: 整个数据库索引是一个单文件 (`.db`)，备份 and 迁移只需配合 `data/` 下的文件即可。
3.  **性能**: 对于内容索引、标签筛选和元数据管理，SQLite 提供极速的响应能力。正文则下沉至文件系统以保持 DB 轻量。

---

## ADR-003: 前后端混合架构 (Hybrid Architecture)

**状态**: ✅ 已采纳  
**类型**: 系统架构

### 决策
采用 "静态优先 + 动态管理" 的混合模式。
-   **访客端 (Viewer)**: 纯静态架构。通过 Fetch API 读取静态 JSON 索引文件，随后按需 Fetch Markdown 内容文件进行异步渲染。
-   **管理端 (Admin)**: 动态架构。在本地 Python 环境下运行，提供 API 接口进行数据索引读写、文件 IO 同步及图像处理。

### 理由
兼顾了静态网站的优势（部署简单、访问快、安全性高）和创作工具的灵活性（利用本地编辑器、物理文件管理）。

---

## ADR-004: 模块化目录结构 (Modular Structure)

**状态**: ✅ 已采纳  
**类型**: 代码组织

### 决策
按业务模块（Feature-based）而非文件类型（Type-based）组织代码。
-   **Structure**: `custom/<module_name>/[admin|viewer]/`
-   **Example**: `custom/cms/viewer/cms-view.module.js`

### 理由
提高代码的高内聚、低耦合。修改特定功能时，相关的所有资源（JS/CSS）都在同一个文件夹下。

---

## ADR-005: ES6 模块化 (ES6 Modules)

**状态**: ✅ 已采纳  
**类型**: 代码规范 / 2026-02-01 更新

### 决策
全面采用 ECMAScript Modules (ESM) 标准。
-   **Structure**: 使用 `import` / `export` 语法。
-   **Extension**: 文件后缀统一为 `.module.js`。
-   **HTML**: 使用 `<script type="module">`。

### 理由
1.  **标准化**: 浏览器原生支持的模块系统，无需 Webpack 等构建工具。
2.  **作用域隔离**: 彻底解决 IIFE 和全局命名空间污染问题。
3.  **依赖清晰**: 静态分析工具可以解析依赖图谱。

---

## ADR-006: 关键路径同步渲染 (Flash Guard)
*💡 关联阅读：[细节设计说明 - 关键渲染路径](细节设计说明.md#1-关键渲染路径与防闪烁-flash-guard)*

**状态**: ✅ 已采纳  
**类型**: 性能优化 / 2026-02-01 更新

### 决策
将防闪烁逻辑 (`flash-guard.js`) 排除在 ES6 模块化之外，保持为**同步阻塞脚本**。
-   在 HTML `<head>` 顶部通过 `<script src="...">` 引用。
-   **禁止**使用 `type="module"` 或 `defer/async`。

### 理由
**关键渲染路径 (Critical Rendering Path)** 要求。
ES6 模块默认延迟执行，会导致页面先渲染（白屏/亮色）再执行脚本（切换深色），造成严重闪烁 (FOUC)。为了用户体验，必须牺牲并发加载，强制阻塞解析以注入初始样式。

---

## ADR-007: CSS 分层架构 (CSS Layering)

**状态**: ✅ 已采纳  
**类型**: 样式管理

### 决策
将样式分解为四层：
1.  **Base**: `cms-base.css` (布局结构)
2.  **Theme**: `cms-theme-default.css`, `literature.css` (视觉主题)
3.  **Module**: 组件级样式
4.  **Mobile (New)**: `custom/zmobile adaptation/` (物理隔离的移动端补丁)

### 理由
1.  **分层管理**: 解决样式覆盖 (`!important`) 泛滥问题，实现主题的灵活切换。
2.  **移动端隔离**: 避免在主文件中散落大量 `@media` 查询，保持主文件的纯净和可维护性。

---

## ADR-008: 图片多级存储 (Multi-level Image Storage)

**状态**: ✅ 已采纳  
**类型**: 资源优化

### 决策
上传图片同时保留三种格式：
1.  **原图**: 原始上传文件 (Backup/Download)
2.  **预览图**: 大尺寸 AVIF (Lightbox)
3.  **缩略图**: 小尺寸 WebP (Gallery Grid)

### 理由
在保证画质的前提下，最大化加载速度并节省带宽。

---

## ADR-009: 统一数据交换格式为 JSON (Unified Data Format)

**状态**: ✅ 已采纳 (全面实施)  
**类型**: 数据交换规范 / 2026-02-06 完成

### 决策
后端服务（`_studio`）生成的静态数据文件统一为标准 JSON 格式（`.json`），不再生成包含 JavaScript 变量赋值的脚本文件（`.js`）。前端通过 Fetch API 异步加载这些数据。

### 理由
1.  **标准化**: JSON 是前后端交换数据的通用标准，独立于编程语言。
2.  **安全性**: 避免在全局作用域污染变量（如 `window.galleryData`）。
3.  **兼容性**: 配合 ES6 Module 的异步加载特性，Fetch JSON 比加载同步 Script 标签更灵活且符合现代 Web 标准。
4.  **一致性**: 解决了前端请求 JSON 但后端生成 JS 导致的 404 或数据不更新问题。

### 替代方案
*   *JSONP / JS 赋值*: 虽然跨域方便且加载快，但污染全局命名空间，且不符合 ES6 模块化隔离的理念。
*   *动态 API*: 对于本项目的“静态生成+动态管理”混合架构，完全动态 API 会丧失纯静态部署的能力。

### 历史变更
*   **2026-02-01**: 初始决策，确立 JSON 优先策略。
*   **2026-02-06**: 全面实施。删除 `album-config.module.js`，移除 `ALBUM_CONFIG_JS` 和 `MUSIC_DATA_JS` 后端配置，全站数据加载完全统一为 `fetch()` + JSON。

---

## ADR-010: 全局命名空间策略 (Global Namespace Policy)

**状态**: ✅ 已采纳 / 2026-02-02 新增
**类型**: 代码规范 / 架构约束

### 决策
1.  **Strict Mode (严禁)**: 业务逻辑模块严禁挂载到全局。
2.  **Explicit Initialization**: 所有基础设施必须通过 `shared/namespace.module.js` 统一显式初始化。
### 允许列表 (Allowlist) 与保留理由
经过深度评估，仅保留了以下 3 个**横切关注点 (Cross-Cutting Concerns)** 的基础设施服务驻留全局。除此之外，严禁挂载。

| 变量名 | 类别 | 保留理由 (Rationale for Retention) |
| :--- | :--- | :--- |
| **`window.MAERS.Toast`** | UI Infrastructure | **全局通知服务**。<br>Toast 需要在任意深度的函数栈中被调用（如 API 报错、验证失败）。将其作为全局单例，避免了在成百上千个函数中反复透传 Toast 对象 (Avoids Prop Drilling)。 |
| **`window.MAERS.Theme`** | UI State | **主题状态管理**。<br>主题（深色/浅色、缩放）是单一事实来源 (Single Source of Truth)，且不依赖于具体业务逻辑。让所有 UI 组件能直接读取当前主题状态是最高效的实现。 |
| **`window.MAERS.ModuleConfig`** | Static Config | **静态配置中心**。<br>提供跨模块的静态元数据（如图标、标题）。它是无状态的常量集合，类似环境变量，允许全局访问以实现“配置驱动开发”。 |

### 架构获益
1.  **解耦**: 防止业务模块间通过全局变量进行隐式通信（"Spooky action at a distance"）。
2.  **工程平衡**: 在纯原生 JS 环境下（无 React Context / Vue Provide），这是处理横切关注点成本收益比最高的方案。

### 历史变更
*   **2026-02-02 20:44**: 移除了 `window.MAERS.CMS.Editor` 桥接接口. Literature 模块改为通过 ES6 import 直接导入 Editor，彻底消除了"向后兼容"的全局挂载。

---

## ADR-011: 跨模块数据持久化与交互策略 (Dual Persistence Strategy)

**状态**: ✅ 已采纳 / 2026-02-02 更新
**类型**: 数据一致性与交互体验

### 背景
系统包含三大核心模块：CMS (Literature/Notes)、Photos (Album)、Music。它们虽然共享同一套 UI 组件（如 `admin-core.module.js` 的 `BatchItemManager`），但底层的数据持久化逻辑截然不同。这导致了早期出现交互行为不一致的问题（如“新建后取消”导致数据在前端回滚）。

### 决策

#### 1. 双重持久化模式 (Dual Strategy)
系统根据模块特性，有意保留两种不同的数据管理模式：

*   **Server-First 模式 (CMS / Photos 模块)**
    *   **适用场景**: `Literature`, `Notes` (文件管理), `Photos` (相册管理)。
    *   **机制**: **混合存储 (Hybrid SQL + Files)**。
        *   CMS Index: `data/cms.db` (存储元数据与文件路径映射)
        *   CMS Content: `data/<module>/*.md` (物理存储正文)
        *   Photos: `data/gallery.db` (存储图片元数据与哈希)
    *   **特性**: 
        *   **立即生效 (Immediate Write)**: 操作通过 Python 实时同步到磁盘文件和数据库。
        *   **双向同步**: 标题变更联动文件名变更，始终保持物理层与逻辑层的一致。
        *   **数据源**: 数据库是索引的事实来源，磁盘文件是内容的事实来源。`*-tree.json` 是静态环境下的索引快照。

*   **Client-First 模式 (Music 模块)**
    *   **适用场景**: `Music` (元数据管理)。
    *   **机制**: **JSON 数据库 (JSON Database)**。前端维护一个庞大的 JSON 对象，所有的添加/排序/删除本质上都是 JS 数组操作。
    *   **特性**:
        *   **批量提交 (Batch Commit)**: 操作只在前端暂存，点击“保存”按钮后才全量覆写整个 JSON 文件。
        *   **静态友好**: 读取非常容易，适合纯静态部署的数据展示。

#### 2. 交互一致性适配 (UI Shim)
为了在 UI 层面上统一这两种模式的体验，实施了以下适配策略：

*   **强制快照同步 (Force Snapshot Sync)**:
    在 **CMS 模块**中，当执行“创建文件”这种立即生效的操作后，**必须强制通过 `refreshView(true)` 重新拉取后端数据，并显式更新 `BatchItemManager` 的快照 (Snapshot)**。
    *   **原因**: 如果不更新快照，前端会认为“原始状态”是创建文件之前的状态。当用户点击“取消修改”时，Manager 会错误地回滚到旧状态，导致新创建的文件在视图中消失（虽然硬盘上还在）。

*   **自动清洗脏数据 (Auto-Sanitization)**:
    在 **Client-First 模式**的保存逻辑中（如 `saveData`），通过 `JSON.parse(JSON.stringify(..., replacer))` 自动过滤掉所有以 `_` 开头的运行时临时字段（如 `_searchStr`, `_deleted`）。
    *   **原因**: 防止前端的临时状态污染持久化的 JSON 文件。

#### 3. 安全与 GitOps 部署
本架构天然支持 GitOps 安全模型：
*   **线上环境 (Production)**: 通常部署在 GitHub Pages / Vercel 等纯静态托管。
    *   **安全性**: 由于后端没有处理 POST 请求的能力（纯静态文件服务），访客即使调用 API 也无法篡改数据。数据是**只读**的。
*   **本地环境 (Local Admin)**: 启动 Python/Node 服务。
    *   **可写性**: 服务端脚本拥有文件写入权限，管理者修改内容后，通过 Git 提交代码变更，自动触发线上的重新部署。

### 结论
*   **统一体验**: 无论底层是操作文件系统还是操作 JSON，用户都享有一致的“所见即所得”和“支持撤销（部分场景）”的体验。
*   **最高安全**: 彻底杜绝了线上被黑客篡改数据的可能性（因为根本没有数据库服务端口开放）。

---

## ADR-012: 轻量级全局配置中心 (Global Configuration)

**状态**: ✅ 已采纳 / 2026-02-03 新增
**类型**: 运维优化

### 决策
引入 `custom/config.js` 作为全局配置入口，挂载于 `window.MAERS.Config`。
该文件在 HTML `<head>` 中**紧接** `flash-guard.js` 之后、所有业务模块之前加载。

### 理由
1.  **环境配置解耦**: 解决了将 API 地址（如 `localhost:8000`）硬编码在业务逻辑（如 `music-ui.module.js`）中的问题，允许在不同部署环境（本地通过 File 协议预览、本地 Python Server、线上静态站）下轻松切换配置。
2.  **非侵入性**: 与 ES6 模块解耦。配置通过全局对象暴露，业务模块只需进行可空检查 (`window.MAERS?.Config?.API_BASE`) 即可使用，无需复杂的注入流程。

---

## ADR-013: 事件驱动 UI 架构 (Event-Driven UI)

**状态**: ✅ 已采纳 / 2026-02-03 新增 (Music 模块试点)
**类型**: 性能优化

### 决策
在核心业务对象（如 `Player`）中实现简单的 Pub/Sub 事件系统 (`on/emit`)，替代原有的轮询 (`setInterval`) 机制来驱动 UI 状态更新。
*   **Before**: `setInterval(() => checkState(), 500)` —— 空闲时浪费 CPU，响应有延迟。
*   **After**: `Player.emit('stateChange')` -> `UI.update()` —— 零延迟响应，零空闲开销。

### 理由
1.  **性能**: 消除无效的 CPU 周期，特别适合长期运行的后台页面（如音乐播放器）。
2.  **响应性**: 用户操作（点击播放）与 UI 反馈（按钮变化）完全同步，提升用户体验。
3.  **解耦**: 状态持有者 (`Player`) 不需要知道谁在关注它，只需广播事件。

---

## ADR-014: 自动化缓存更新策略 (Service Worker)

**状态**: ✅ 已采纳 / 2026-02-03 新增
**类型**: 部署与运维

### 背景
Cloudflare 等 CDN 的强缓存策略导致新部署的代码（尤其是 CSS/JS）无法即时生效，用户需要手动清理缓存。

### 决策
采用 **Service Worker 拦截 (Cache Busting)** 方案。
1.  **控制中心**: 根目录下 `maers-version-controller.js`。
2.  **机制**: SW 拦截全站所有同源请求，自动追加版本号参数 (e.g. `?maers_ver=2026.02.03`)。
3.  **触发方式**: 开发者只需修改 controller 文件中的 `VERSION` 常量，全站缓存即刻失效并回源更新。

### 理由
此方案无需 Webpack 等构建工具即可实现“发布即生效”，完美适配本项目的原生架构。

---

## ADR-015: 智能上下文导航 (Smart Context Navigation)

**状态**: ✅ 已采纳 / 2026-02-04 新增
**类型**: 用户体验 (UX) / 交互逻辑

### 背景
在传统的树状文件系统中，"搜索结果"通常是一个扁平列表。当用户从搜索结果中点击一个文件时，传统的做法是直接打开文件，但用户往往有"查看该文件所在目录"的需求（Context Recovery）。

### 决策
系统引入了 **Context-Aware Navigation** 机制：
1.  **检测 (Detection)**: 点击文件时，自动判断该文件是否在当前可视列表 (View List) 中。
2.  **询问 (Intervention)**: 如果文件不在当前列表中（即属于"Out-of-View"），弹窗询问用户意图：**"仅预览"** 还是 **"跳转到目录"**。
3.  **遮罩 (Overlay)**: 在筛选/搜索视图下，强制在面包屑导航栏显示 `"All"` 遮罩层，从视觉上明确区分 "Filtered View" 和 "Physical Folder View"，防止用户对当前所处路径产生混淆。

### 理由
1.  **尊重用户意图**: 避免了"一搜即跳"导致的上下文丢失，也避免了"只能看不能跳"的信息孤岛。
2.  **消除歧义**: 通过 "All" 遮罩层，解决了面包屑路径与实际显示内容不符（路径显示 A/B/C，但列表显示所有匹配项）的认知冲突。

---

## ADR-016: 乐观 UI 删除 (Optimistic UI Deletion)

**状态**: ✅ 已采纳 / 2026-02-04 新增
**类型**: 用户体验 (UX) / 状态管理

### 背景
在多标签筛选模式下，简单的增量渲染 (Diff Render) 无法正确识别节点的删除状态，导致用户在删除文件后，视觉上卡片依然残留在列表中（因为列表是过滤后的视图，Diff 算法可能失效）。

### 决策
在 `performSave` 删除流程中引入 **Optimistic UI Deletion** 策略：
1.  **后端确认**: 等待后端 API 返回删除成功的确认。
2.  **强制 DOM 操作**: 不等待 View 层的通用刷新逻辑，而是直接查询 DOM 节点并立即调用 `remove()`。
3.  **兜底重置**: 随后调用 `refreshView(true, true)`，强制重置 `BatchItemManager` 并重新加载全部数据。

### 理由
这种 "先斩后奏" + "事后核实" 的策略，完美解决了复杂筛选状态下的视图同步问题，提供了即时的交互反馈。
**容错性说明**：如果在第 2 步（强制 DOM 操作）完成但第 3 步（兜底重置）执行前系统出现异常（如脚本崩溃），可能会导致浏览器内存中残留脏数据。但由于文件通过第 1 步已在后端物理删除，**数据本身是安全且正确的**。此时用户只需**重新同步 JSON（即刷新页面）**，脏数据即可自动清除，不会造成不可逆的后果。

---

## ADR-017: 移动端极致性能降级 (Mobile Extreme Performance Degradation)
*💡 关联阅读：[细节设计说明 - 移动端适配策略](细节设计说明.md#11-移动端适配策略-mobile-adaptation-strategy)*

**状态**: ✅ 已采纳 / 2026-02-04 新增
**类型**: 性能策略 / 用户体验

### 背景
移动端设备（特别是旧款机型）在渲染复杂 CSS 特效（如高斯模糊 `backdrop-filter`、SVG 噪声遮罩 `mask-image`、大面积渐变过渡）时，会出现显著的掉帧、卡顿和发热问题。早期的“优雅降级”策略（保留过渡动画但简化背景）已被证明在性能上仍不达标。

### 决策
采用 **"看不见就不做 (Do Nothing Invisible)"** 的激进降级策略。
针对移动端（`max-width: 1024px`）：
1.  **移除动画 (Zero Transition)**: 强制设置 `transition: none !important`。主题切换由“渐变”改为“瞬间反转”。
2.  **隐藏遮罩 (Hide Overlays)**: 将原用于提供质感的全屏噪点/星空遮罩层 (`#theme-mask`) 在运行时完全 `display: none`。
3.  **扁平化 (Flattening)**: 移除所有毛玻璃效果、阴影和圆角，回归最基础的扁平色块。

### 理由
1.  **流畅度优先**: 在小屏幕设备上，用户对“点击反馈速度”的敏感度远高于“背景是否有颗粒感”。瞬间切换带来的响应感优于卡顿的动画。
2.  **视觉无关性**: 许多 PC 端的高级纹理细节在手机小屏幕和高 DPI 下根本无法被肉眼察觉，渲染它们是纯粹的 GPU 资源浪费。

---

## ADR-018: 统一 SVG 图标体系 (Unified SVG Icon System)

**状态**: ✅ 已采纳 / 2026-02-04 新增
**类型**: 视觉规范 / 用户体验

### 背景
早期项目大量使用 Emoji 字符作为图标（如 🗻, 🌿, 🎧）。Emoji 在不同系统、浏览器中渲染风格差异大，且在 Retina/高清屏下会模糊，难以进行精确的 CSS 主题配对。

### 决策
1.  **全面转换 (Full Transition)**: 废弃非装饰性的 Emoji 图标，核心业务模块（Music, Video, Admin Panels, Gallery Categories）全面转向原生的 SVG 图标 (`.svg`)。
2.  **动态包装策略 (Dynamic Wrapping Strategy)**:
    -   **Admin 端**: 数据层保持干净的路径引用（如 `ui/icon.svg`）。View 层渲染时自动转换为 `<img>` 标签，实现“配置即所得”。
    -   **兼容性**: 渲染器必须保留对原生 Emoji 的 `innerHTML` 直传能力，确保向下兼容。
3.  **交互式路径处理**: 管理工具支持在输入时自动检测路径字符串（包含 `/` 或 `.`），并自动包装为带样式的 HTML 标签。

### 理由
1.  **视觉连贯性**: SVG 提供了矢量级的清晰度和跨平台的一致性。
2.  **易于维护**: 图标文件物理化为 `ui/*.svg`，允许通过文件名管理资源，而不再是硬编码的 Unicode 字符。
3.  **可扩展性**: 方便未来通过 CSS Filter 或微动画增强图标表现力。

---

## ADR-019: 核心主题与脚本统一 (Theme Unification)

**状态**: ✅ 已采纳 / 2026-02-05 新增
**类型**: 代码维护 / 架构简化

### 背景
随着项目发展，Admin 页面的交互逻辑（拖拽、缩放、主题切换）逐渐分散。早期的 `script.module.js` 承担了部分 Admin 交互，而 `theme.module.js` 承担了前台主题，两者逻辑重叠且维护困难。且 Admin 页面需要手动引入 `drag.css`，易因遗漏导致样式崩坏。

### 决策
1.  **合并与废弃**: 将 `script.module.js` 的所有核心功能（Zoom, Drag, Iframe Click Handling）迁移至 `shared/theme.module.js`，并彻底删除旧脚本。
2.  **自动注入样式**: `theme.module.js` 初始化时会自动检测并向 `<head>` 注入 `drag.css` 链接。
    -   **Benefit**: Admin 页面只需引用 JS，无需关心底层 CSS 依赖。
3.  **HTML 优先的标题渲染**: 明确了涉及富文本（如图标）的标题渲染必须使用 `innerHTML` 并辅以可信源验证，而非 `textContent`，以支持 `<img>/ <svg>` 渲染。

### 理由
1.  **单一事实来源**: 所有与“界面交互体验”相关的逻辑统一收口，降低认知负荷。
2.  **DX 提升**: 开发者新建页面时，引用链更短，出错概率更低。

---

## ADR-020: 交互式身份验证物理删除 (Secure Deletion Confirmation)

**状态**: ✅ 已采纳 / 2026-02-05 新增
**类型**: 系统安全 / 交互设计

### 背景
管理端操作（如删除页面或相册分类）涉及物理文件的删除。传统的 `confirm()` 确认框（Ok/Cancel）在用户疲劳或手快时容易被误点，导致不可挽回的数据损失（尤其是在服务器磁盘上直接执行 `os.remove` 或 `shutil.rmtree` 时）。

### 决策
1.  **验证码化删除**: 废弃简单的“确认”按钮。
2.  **关键标识校验**: 执行高危删除前，弹出 `prompt()` 窗口，强制用户手动输入待删除对象的**唯一标识符**（如页面文件名 `index.html` 或分类 ID `travel`）。
3.  **完全匹配校验**: 仅当用户输入与目标完全匹配时，后端才会接收并执行删除请求。

### 理由
1.  **引入思维干预**: 强迫用户在执行动作前进行一次微小但有效的“二次思考”，能阻断 99% 的误操作路径。
2.  **数据安全性**: 在缺乏版本回滚机制的原生架构下，这是确保物理文件安全的成本最低、效果最好的方案。

---

## ADR-021: Studio Engine 标准化双语日志回显 (Standardized Logging)

**状态**: ✅ 已采纳 / 2026-02-05 新增
**类型**: 开发体验 (DX) / 系统设计

### 背景
后端（Python）存在多个服务模块。随着系统复杂度增加，传统的、无格式的控制台打印（`print`）导致开发者难以在海量日志中快速区分当前正在执行的业务逻辑及其成败。

### 决策
1.  **统一前缀标识**: 引入名为 "Studio Engine" 的日志标准。所有回显必须包含 `[ MODULE ] 图标` 的对齐标识（如 `[ ALBUM ] 🆕`）。
2.  **强制双语回显**: 将所有用户/开发者可见的控制台反馈升级为“中文 | 英文”对照格式。
3.  **视觉语义化**: 规定了特定操作对应的图标规范（✨ 页面, 🗑️ 删除, 🌐 联网等）。

### 理由
1.  **专业交互感**: 赋予系统一种“实验室设备”般的交互质感，符合项目整体的高端审美定位。
2.  **极速诊断**: 对齐的方括号标签使开发者一眼就能识别出是否有报错或异常操作。
3.  **国际化预留**: 为系统的潜在国际协作提供了基础的底层支持。

---

## ADR-022: 模块微服务化重构与职责隔离 (Micro-Modular Refactoring)

**状态**: ✅ 已采纳 / 2026-02-06 新增
**类型**: 软件工程 / 可维护性

### 背景
随着业务逻辑深度增加，原有的“一大三小”单体模块架构（如单文件 `theme.module.js`）在面临高频交互（如拖拽+缩放+主题切换）时，代码膨胀严重，且模块内部私有状态管理混乱，导致定位 Bug 困难。

### 决策
1.  **子模块化拆分 (Sub-modularization)**: 将庞大的单体模块拆分为具有明确单一职责的子模块。
    -   **Theme**: 拆分为 `theme-core` (状态), `theme-drag` (交互), `theme-zoom` (视控)。
    -   **Admin**: 拆分为 `admin-manager` (逻辑), `admin-ui` (视觉), `admin-button-helper` (注入)。
    -   **Tags**: 拆分为 `cms-tags-drawer` (UI), `cms-tags-filter` (逻辑)。
2.  **物理目录隔离**: 子模块必须存放在父模块对应的子目录下（如 `shared/theme/`），禁止与根目录模块混放。
3.  ** facade 入口模式**: 保留主入口模块（如 `shared/theme.module.js`）作为外观模式 (Facade Pattern)，负责协调子模块的加载与初始化，确保向后兼容性。

### 理由
1.  **降低认知负荷**: 开发者每次只需关注不到 300 行的小文件。
2.  **避免死代码**: 明确了功能边界，使得不被某个页面使用的子模块逻辑不会被意外触发。
3.  **团队协作优化**: 不同开发者可以同时且独立地修改同一个大特性的不同逻辑块，而互不干扰。

---

## ADR-023: 管理端物理操作反馈增强 (Associated Feedback)

**状态**: ✅ 已采纳 / 2026-02-06 新增
**类型**: 用户体验 / 安全设计

### 背景
旧版系统的物理文件（如图片目录）删除操作在前端缺乏明确的反馈闭环。管理员在执行“删除分类”或“删除图片”后，无法直观确认服务器是否同步清理了高占用的物理文件，导致“幽灵文件”焦虑。

### 决策
1.  **明确的物理反馈语**: 将 UI 反馈术语从模糊的“已删除”升级为精确的“关联物理图片已同步粉碎/删除”，并在 Toast 中高亮显示。
2.  **交互透明化**: 在涉及物理删除的流程（如 `album-admin.module.js`）中，Prompt 弹窗必须通过显式的 ID 输入校验来授权物理操作，并在操作成功后立即给出特定的成功通知。
3.  **术语标准化**: 全站统一使用 **"关联目录/关联图片" (Associated)** 指代底层物理文件，避免使用过于技术化的 "OS path" 或模糊的 "Data"。

### 理由
1.  **消除操作焦虑**: 明确的物理反馈能极大增强用户对系统的信任感。
2.  **防止数据残留**: 强化的交互流程倒逼开发者在后端实现更严谨的清理逻辑 (`shutil.rmtree`)。

---

## ADR-024: 中央保存调度架构 (Centralized Save Coordination)
*💡 关联阅读：[细节设计说明 - 保存条调度](细节设计说明.md#15-cms-保存条调度与标签管理-20)*

**状态**: ✅ 已采纳 / 2026-02-06 新增
**类型**: 系统架构 / 交互逻辑

### 背景
在复杂的管理界面（如 CMS 和 Photos）中，存在多个平行的管理维度（文件/图片列表与标签列表）。如果每个维度都独立控制一个“保存/取消”按钮，会导致界面上出现多个浮动条，引发严重的视觉冲突和复杂的竞态条件。

### 决策
1.  **控制权上移**: 引入“中央调度器”模式（由 `admin-main.module.js` 或 `photos-admin-main.module.js` 担任）。
2.  **哑子管理器 (Dumb Sub-managers)**: 所有的列表管理器（`BatchItemManager`）在初始化时被赋予 `autoSaveBar: false` 配置。
3.  **聚合脏检查 (Aggregated Dirty Check)**: 中央调度器负责轮询所有子管理器的脏状态。只要有一个模块是“脏”的，中央保存条就会显示。
4.  **原子化批量保存**: 用户点击保存时，调度器会按业务优先级顺序（如先保存文件树，再保存标签）依次调用子管理器的 `performSave`。

### 理由
1.  **极简交互**: 确保界面始终只有一个明确的“动作中心”，消除用户困惑。
2.  **避免闪烁**: 子模块在频繁交互时不会各自弹出或关闭保存条，提供了更稳定的视觉反馈。
3.  **数据一致性**: 通过顺序提交，降低了多来源数据并发冲突的风险。

---

## ADR-025: 稳定随机化离散流动布局 (Stable Randomized Flow Layout)

**状态**: ✅ 已采纳 / 2026-02-06 新增
**类型**: 渲染架构 / 数学模型

### 背景
文学模块的 Flow 视图在不同屏幕宽度下存在书籍重叠、转弯由于缓冲区不足导致提前调头、以及书籍重复出现时过于集中的问题。

### 决策
1.  **参数化解耦 (Parametric Decoupling)**: 建立“间距-数据量-视口”三位一体的数学关联函数。系统现在能自动适配任意数据量（36-200+）和任意间距（10-50px）。
2.  **绝对物理间距**: 放弃百分比排版，采用 `cardWidth + spacing` 的绝对槽位模型。
3.  **回路长度取整 (Track Quantization)**: 强制回路总长为间距的整数倍，通过 `Math.ceil(minLen / spacing) * spacing` 确保首尾衔接无跳变。
4.  **动态离屏跑道 (Dynamic Runway)**: 缓冲区 `boundaryMargin` 根据回路长度动态吸纳余量，保证至少 200px 的转弯半径，彻底解决窄屏显示异常。
5.  **稳定随机映射 (Stable Randomized Mapping)**: 引入 `slotMapping` 查找表，针对重复项执行随机抽样与洗牌，同时确保 DOM 元素与物理槽位的强绑定。

### 理由
1.  **参数化解耦**: 开发者只需修改常量即可自动适配所有屏幕尺寸。
2.  **绝对物理间距**: 确保了视觉上的整齐与专业感。
3.  **零重复感知**: 即使在书籍较少的大屏幕上，通过随机散落逻辑，用户也很难察觉到书籍的重复循环。

---

## ADR-026: 客户端模板引擎 (Client-side Templating)

**状态**: ✅ 已采纳 / 2026-02-08 新增
**类型**: 安全性 / 性能优化

### 背景
随着 UI 复杂度增加（如 CMS 卡片上的多个操作按钮、标签的多态展示），原有的“JS 字符串拼接”模式 (`html += '<div class="...">...</div>'`) 暴露出两个问题：
1.  **XSS 风险**: 拼接也是一种“内联 HTML”，如果变量未严格转义，易导致注入漏洞。
2.  **维护困难**: 在 JS 字符串中编写 HTML 没有语法高亮，且难以阅读。

### 决策
引入 `shared/templates.module.js` 作为轻量级模板引擎：
1.  **机制**: 基于 HTML5 `<template>` 标签。
2.  **流程**: 
    -   **Register**: 在 JS 中注册模板字符串（或从 DOM 加载）。
    -   **Clone**: 使用 `template.content.cloneNode(true)` 生成 DOM 片段。
    -   **Fill**: 通过 `data-text`, `data-if`, `data-class` 等自定义属性自动填充数据，实现逻辑与视图分离。

### 理由
1.  **原生安全**: 使用 `textContent` 填充 `data-text`，天然免疫 XSS 攻击。
2.  **高性能**: `cloneNode` 比 `innerHTML` 解析字符串更快。
3.  **标准化**: 符合 Web Components 的演进方向。

---

## ADR-027: 显式命名空间初始化 (Explicit Namespace Initialization)

**状态**: ✅ 已采纳 / 2026-02-09 新增
**类型**: 架构规范

### 背景
虽然 ADR-010 限制了全局变量的使用，但 `MAERS.Toast`, `MAERS.Theme` 等基础设施仍需挂载。由于 ES6 模块加载顺序的不确定性，曾出现子模块尝试挂载 `MAERS.CMS` 但 `MAERS` 主对象尚未存在的报错。

### 决策
1.  **单一入口**: 创建 `shared/namespace.module.js`。
2.  **职责**: 负责初始化 `window.MAERS` 及其所有一级/二级子对象（如 `MAERS.CMS`, `MAERS.Music`）。
3.  **强制前置**: 所有核心模块必须（或隐式地通过基础设施）依赖此模块，确保在业务逻辑执行前，命名空间树已构建完毕。

### 理由
消除“undefined behavior”，确保运行时环境的确定性。

---

## ADR-028: 文件驱动内容存储 (File-based Content Storage)

**状态**: ✅ 已采纳 / 2026-02-12 新增
**类型**: 数据架构 / 核心重构

### 背景
随着项目数据量增长，将 Markdown 正文直接存储在 SQLite 的 `content` 字段中开始暴露弊端：
1. **开发者体验差**: 即使在 Admin 模式下，也必须依赖系统内置编辑器，无法利用外部专业工具（如 VS Code, Typora）的强大生态。
2. **备份与索引**: 数据库是黑盒，无法进行简单的文本全局搜索、Git 历史追踪或跨模块内容复用。
3. **数据冗余**: JSON 树状快照文件会随着正文内容的增加而急剧膨胀，导致前端首屏加载压力。

### 决策
1. **混合存储模型**: 
   - **SQLite**: 仅作为“索引与元数据引擎”。存储 ID、标题、层级关系、标签、物理文件路径。
- **Markdown 文件**: 作为“单一事实真理”。存储文章的实际文本内容，存放在 `data/<module>/` 目录下。
2. **文件名驱动同步**: 后端 `cms.py` 确保 `.md` 文件名与节点标题自动同步。标题修改时，物理文件名同步重命名，实现“所见即所得”的文件组织。
3. **延迟加载 (Lazy Loading)**: 前端模块详情页不再随树节点一次性获取内容。渲染详情时，根据数据库中的路径异步 `fetch` 对应的 `.md` 文件。

### 理由
1. **开发者解放**: 允许开发者直接在 VS Code 里操作 `data/` 目录，无需启动 Web 后台即可完成高质量创作。
2. **性能飞跃**: `*-tree.json` 提及的内容量减少了 90% 以上，极大地降低了前端解析压力和内存占用。
3. **透明度**: 内容变得透明且可移植，你可以用任何支持 Markdown 的工具打开该项目。

---

## ADR-029: JSON 驱动标签配置 (JSON-based Tag Configuration Storage)
*💡 关联阅读：[细节设计说明 - 标签管理 2.0](细节设计说明.md#15-cms-保存条调度与标签管理-20)*

**状态**: ✅ 已采纳 / 2026-02-12 新增
**类型**: 数据架构 / 模块解耦

### 背景
旧版系统的标签分类配置（Categories）存储在数据库的 `_TAG_CONFIG` 虚拟节点中。这种方式存在以下局限：
1. **字段污染**: 数据库核心表 `nodes` 包含非内容节点，增加了逻辑判断复杂度。
2. **管理不便**: 修改标签配置需要操作数据库大字段，不利于 Git 版本追踪和手动紧急修复。
3. **扩展性差**: 不同模块（Notes, Literature等）竞争同一个配置入口。

### 决策
1. **物理配置化**: 彻底移除数据库中的 `_TAG_CONFIG` 节点。
2. **独立 JSON 存储**: 每个模块的标签分类配置独立存储于 `data/tags/cms-{module}-tag-categories.json`。
3. **标准化接口**: 后端 API 统一封装 `get_tag_categories` 和 `save_tag_categories` 逻辑，支持跨模块的标签配置读写。

### 理由
1. **GitOps 友好**: 标签分类作为一种“配置”，理应以明文文本形式存在，方便团队协作与版本回滚。
2. **职责清晰**: 数据库仅负责业务数据（节点），文件系统负责结构配置（标签定义），符合 ADR-022 的职责隔离原则。
3. **极致性能**: 前端初始化侧边栏时直接 Fetch 专用的轻量 JSON，无需解析庞大的数据库全文索引。

---

## ADR-030: 标准浏览器级懒加载 (Standard Browser-level Lazy Loading)

**状态**: ✅ 已采纳 / 2026-02-12 新增
**类型**: 性能优化 / 标准化

### 背景
早期为了控制图片加载时机和实现 object-fit 效果，项目大量使用了 `div.background-image` 配合 `IntersectionObserver` 的 JS 懒加载方案。这一方案存在明显的 SEO 缺陷（搜索引擎不抓取背景图），且无法被用户通过右键菜单直接保存。

### 决策
1. **拥抱原生标准**: 废弃所有 JS 模拟的懒加载逻辑。全面使用 `<img loading="lazy">` 属性。
2. **标签语义化**: 将所有的缩略图容器从 `div` 替换为语义化的 `img` 标签。
3. **样式适配**: 利用 `object-fit: cover` 实现原先背景图的裁剪效果。

### 理由
1. **代码删减**: 移除了数百行用于计算视口的 JS 代码，显著降低了 Runtime 开销。
2. **体验升级**: 用户现在可以对着缩略图 "右键 -> 另存为"，符合 Web 使用直觉。
3. **SEO 友好**: 爬虫可以正确索引图片内容。

---

## ADR-031: 原子化通知系统 (Atomic Notification System)

**状态**: ✅ 已采纳 / 2026-02-12 新增
**类型**: 交互体验 (UX)

### 背景
在执行复杂操作（如“删除相册并清理物理文件”）时，原本系统只弹出一个笼统的“操作成功”通知。用户无法确定到底哪些步骤被执行了（比如，物理文件真的删了吗？）。

### 决策
1. **反馈解耦**: 将单一的业务操作拆解为多个原子化的反馈事件。
2. **多通道回显**: 
    - **逻辑层**: 弹出 "相册分类已删除" (Gallery Deleted)。
    - **物理层**: 紧接着弹出高亮的 "关联物理文件已粉碎" (Physical Files Purged)。
3. **独立队列**: Toast 系统支持消息队列，保证多条消息依次展示，不会相互覆盖。

### 理由
通过将“看不见”的服务器操作（如删除文件）显性化为独立的通知，极大地增强了用户对系统的信任感和掌控感。

---

## ADR-032: 标签配置命名规范 (Tag Configuration Naming Convention)

**状态**: ✅ 已采纳 / 2026-02-12 新增
**类型**: 代码规范

### 决策
为了配合 ADR-029 (JSON 驱动标签)，严格规定了 `data/tags/` 目录下配置文件的命名格式：
- **Format**: `cms-{module}-tag-categories.json`
- **Example**: `cms-notes-tag-categories.json`, `cms-photos-tag-categories.json`
- **Constraint**: 必须包含 `cms-` 前缀和 `-tag-categories` 后缀。

### 理由
1. **自动化识别**: 方便后端脚本 (`wipe-data.py`, `backup.py`) 通过正则模式批量识别和处理所有标签配置文件。
2. **命名空间隔离**: 防止与其他类型的 JSON 数据文件混淆。


