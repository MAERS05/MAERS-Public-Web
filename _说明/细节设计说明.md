# MAERS 细节设计说明

本文档深入阐述项目中关键功能的实现细节与设计考量。

---

## 📋 目录 (Table of Contents)

- [1. 关键渲染路径与防闪烁](#1-关键渲染路径与防闪烁)
- [2. CMS 编辑器集成](#2-cms-编辑器集成)
- [3. 模块间通信机制](#3-模块间通信机制)
- [4. 音乐播放器架构](#4-音乐播放器架构)
- [5. 配置驱动架构 (Config-Driven Architecture)](#5-配置驱动架构-config-driven-architecture)
- [6. 基础设施服务模式 (Infrastructure Services)](#6-基础设施服务模式-infrastructure-services)
- [7. 高级状态管理与视图同步 (Advanced State & Sync)](#7-高级状态管理与视图同步-advanced-state--sync)
- [8. 快速访问与固定机制 (Quick Access & Pinning)](#8-快速访问与固定机制-quick-access--pinning)


---

## 1. 关键渲染路径与防闪烁 (Flash Guard)

### 1.1 问题描述
在支持 Dark Mode 的网站中，如果 CSS/JS 加载延迟，用户会看到错误的浅色主题或无样式内容 (FOUC)。本项目采用 ES6 模块，其延迟加载特性加剧了此问题。

### 1.2 解决方案：同步阻塞脚本
我们在 `<head>` 中插入了一个极其微小的同步脚本 `flash-guard.js`。

**流程：**
1.  浏览器解析 HTML 到 `<head>`。
2.  遇到 `flash-guard.js`，暂停解析，下载并执行。
3.  **Script Execution**:
    -   检查 `LocalStorage` 中的主题偏好。
    -   立即给 `<html>` 添加 `light-mode` 类（如果是浅色）。
    -   **Critical**: 立即给 `<html>` 设置内联 `style="background-color: ..."` 作为 CSS 加载前的视觉兜底（Fallout）。
    -   立即插入一个全局 `style` 标签，给 `html.js-loading` 添加全屏背景遮罩。
4.  脚本执行完毕，浏览器继续解析 CSS 和 Body。
5.  页面渲染第一帧时，遮罩已存在，且底色正确，用户看不到 FOUC。
6.  **Cleanup (关键)**: 页面加载完毕 (DOMContentLoaded) 100ms 后，执行 `removeGuard()`：
    -   移除 `js-loading` 类。
    -   **移除内联 `background-color` 和 `color`**。这是防止后续主题切换失败的关键，确保 CSS 变量能接管样式。

---

## 2. CMS 编辑器集成

### 2.1 Vditor 选择
我们选择了 `Vditor` 作为 Markdown 编辑器，因其支持即时渲染 (WYSIWYG) 和分屏预览。

### 2.2 资源隔离
为了不影响访客加载速度，编辑器资源仅在 `admin.html` 中引用。访客端使用轻量级的 `marked.js` 进行单纯的 HTML 渲染。

---

## 3. 模块间通信机制

在迁移到 ES6 后，我们移除了全局事件总线 (**Global Event Bus**)。

### 3.1 显式依赖与注入 (Dependency Injection)
除了基本的 `import`，我们在核心模块（尤其是 CMS）中广泛采用了依赖注入模式。
*   **做法**: 模块不再直接导入具体的状态单例，而是通过 `init(State, Render...)` 函数接收依赖。
*   **优势**: 极大降低了耦合度。例如，`Drag` 模块不需要知道 `State` 来自哪里，只要接口一致即可。这也使得 Literature 模块能够轻松复用 CMS 的组件。

### 3.2 观察者模式 (Observer Pattern)
对于复杂的状态同步（如音乐播放进度），我们使用轻量级的订阅发布模式，但限制在 `MusicPlayer` 类内部，不对外暴露全局事件。

---

## 4. 音乐播放器架构

### 4.1 PiP (Picture-in-Picture)
播放器不仅是一个底栏，还支持悬浮窗模式。实现上通过改变容器的 `position: fixed` 和层级来实现，而非浏览器原生的 Video PiP API（因为我们需要显示歌词和封面）。

### 4.2 状态持久化
播放状态（当前歌曲、进度、音量）实时写入 `LocalStorage`。用户刷新页面或跳转页面后，通过 `flash-guard.js` 或初始化脚本恢复状态，实现"无缝播放"的错觉。

---

## 5. 配置驱动架构 (Config-Driven Architecture)

为了最大化复用 CMS 逻辑（既支持笔记，也支持文学，甚至相册配置），我们建立了一个静态配置中心 `module-config.module.js`。

### 5.1 核心思想
**Code Once, Configure Everywhere**.
CMS 模块不包含任何硬编码的字符串（如 "Study Notes" 或 "Literature"）。它仅仅在运行时询问 Config："我现在的名字叫什么？我的图标是什么？我允许用户修改标签吗？"

### 5.2 全局可访问性
为了让这个配置对全站透明，它被挂载在 `window.MAERS.ModuleConfig`。这是经过严格审视的架构决策，因为它仅仅包含只读的静态数据（Metadata），不包含状态，因此没有并发风险，且极大地简化了深层组件获取配置的复杂度。

### 5.3 数据结构示例
```javascript
{
    literature: {
        title: 'Literature',
        allowTags: true,
        allowMove: true,
        dataFile: 'data/literature-tree.json'
    }
}
```
CMS 通过读取 `dataType` 属性（如 `current=literature`）来自动切换行为模式。

---

## 6. 基础设施服务模式 (Infrastructure Services)

我们在架构中严格区分了**业务逻辑**与**基础设施**。

### 6.1 定义
*   **业务逻辑 (Business Logic)**: 如相册渲染、音乐播放、笔记编辑。这些必须模块化，严格封装。
*   **基础设施 (Infrastructure)**: 如全局通知 (`Toast`)、主题状态 (`Theme`)。这些是“横切”整个应用的。

### 6.2 单例模式 (Singleton Pattern)
对于基础设施，我们采用挂载在 `window.MAERS` 下的单例模式。

**为什么不用 import?**
如果现在的 50+ 个业务文件都要报错，它们都需要写：
`import { Toast } from '../../shared/ui/toast.module.js'`
这产生了大量的样板代码 (Boilerplate) 和硬编码路径。

**设计决策**:
我们将 Toast 和 Theme 视为**运行时环境 (Runtime Environment)** 的一部分。就像浏览器自带 `alert()` 和 `console.log()` 一样，MAERS 运行环境自带 `MAERS.Toast.error()`。这种设计极大地提升了开发体验 (DX)，同时并未破坏业务逻辑的解耦。

---

## 7. 高级状态管理与视图同步 (Advanced State & Sync)

### 7.1 "伪删除"与强制即时反馈 (Optimistic UI Deletion)
在多标签筛选模式下，简单的增量渲染 (Diff Render) 无法正确识别节点的删除状态，导致用户感觉删除失败。

**解决方案：**
我们在 `performSave` 中引入了 **Optimistic UI Deletion** 策略：
1.  一旦后端返回删除成功的确认。
2.  **强制操作 DOM**：不再等待 View 刷新，而是直接使用 `querySelector` 找到对应的卡片并立即 `remove()`。
3.  **兜底重置**：随后调用 `refreshView(true, true)`，强制重置 `BatchItemManager` 并重新加载全部数据，确保数据的一致性。

这种 "先斩后奏" + "事后核实" 的策略，完美解决了复杂筛选状态下的视图同步问题。

### 7.2 智能导航与筛选保持 (Persistent Filter Navigation)
为了支持在筛选状态下穿梭文件夹（例如：只看 "#工作" 标签的文件，然后点进 "2024项目" 文件夹，依然只想看 "#工作" 的文件）。

**实现：**
我们在 `navigateTo` 和 `enterFolder` 中增强了逻辑：
*   **Context Awareness**: 导航前先检查 `Search` 模块是否有活跃的 filter。
*   **Dynamic Scope**: 如果有 filter，不再盲目重置为全量列表，而是调用 `Search.applyFilter()`。
*   **Scoped Search**: 修改了 `Search` 模块，使其支持基于当前 `pathNode.children` 进行局部筛选，而不仅仅是全局筛选。

这创造了一种连贯的 "筛选视界"，用户感觉自己是在一个 "过滤后的平行文件系统" 中漫游。

### 7.3 标签搜索联动 (Auto-Expand Drawer)
为了提升标签管理的效率，当用户搜索标签（如 "Sci-Fi"）时：
1.  系统不仅只显示匹配的标签。
2.  还会**自动展开** (Auto-Expand) 包含这些标签的父分类（如 "Genre"）。

这是通过在 `cms-tags.module.js` 的 `refreshDrawerList` 循环中，动态向 `expandedCategories` 集合添加匹配分类名来实现的。

---

## 8. 快速访问与固定机制 (Quick Access & Pinning)

### 8.1 模块隔离存储
为了避免不同模块（笔记、文学、随笔）的访问历史混淆，`cms-recent.module.js` 采用了动态存储键名策略。
*   **Key 生成**: `maers_recent_${moduleName}` (例如 `maers_recent_literature`)。
*   **好处**: 用户在“文学”模块的访问记录不会污染“笔记”模块的侧边栏。

### 8.2 固定 (Pinning) 逻辑设计
我们将用户“固定”的项目与“最近访问”的项目混合存储在同一个数组结构中（便于携带时间戳和元数据），但通过 `pinned: true` 属性进行区分。
*   **渲染分离**: 在 UI 层，我们人为地将数组拆分为 `Fixed Access` 和 `Recent Access` 两个 DOM 区域。
*   **交互**: 点击图钉图标会简单地切换该属性并重新排序/渲染。
*   **视觉反馈**: 实现了 `unpin-line` 动画，当鼠标悬停在已固定的图钉上时，显示一条划线，直观表达“取消固定”的语义。

### 8.3 跨模块视图集成 (CustomView Injection)
由于 Literature 模块拥有独特的 Flow Engine（3D 动画），直接调用 Editor 打开文件会导致性能浪费和遮挡问题。
我们实现了一种**视图注入**机制：
1.  **View 层扩展**: `cms-view.module.js` 新增 `CustomView` 插槽。
2.  **模块注册**: Literature 初始化时，将 `LiteratureView` 注册为 `CustomView`。
3.  **智能调用**: 当 Quick Access 触发打开请求时，View 层优先检查 `CustomView.openNode`。如果存在， Literature 模块会先负责**暂停动画**、**隐藏 3D 舞台**，然后再打开编辑器。这也是多态架构的体现。
