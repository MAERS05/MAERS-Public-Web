# MAERS 细节设计说明

本文档深入阐述项目中关键功能的实现细节与设计考量。

---

## 📋 目录 (Table of Contents)

- [1. 关键渲染路径与防闪烁](#1-关键渲染路径与防闪烁)
- [2. CMS 编辑器集成](#2-cms-编辑器集成)
- [3. 模块间通信机制](#3-模块间通信机制)
- [4. 音乐播放器架构](#4-音乐播放器架构)

---

## 1. 关键渲染路径与防闪烁 (Flash Guard)

### 1.1 问题描述
在支持 Dark Mode 的网站中，如果 CSS/JS 加载延迟，用户会看到错误的浅色主题或无样式内容 (FOUC)。本项目采用 ES6 模块，其延迟加载特性加剧了此问题。

### 1.2 解决方案：同步阻塞脚本
我们在 `<head>` 中插入了一个极其微小的同步脚本 `flash-guard.js`。

**流程：**
1.  浏览器解析 HTML 到 `<head>`。
2.  遇到 `flash-guard.js`，暂停解析，下载并执行。
3.  **Script Execution**:
    -   检查 `LocalStorage` 中的主题偏好。
    -   立即给 `<html>` 添加 `light-mode` 类（如果是浅色）。
    -   **Critical**: 立即给 `<html>` 设置内联 `style="background-color: ..."` 作为 CSS 加载前的视觉兜底（Fallout）。
    -   立即插入一个全局 `style` 标签，给 `html.js-loading` 添加全屏背景遮罩。
4.  脚本执行完毕，浏览器继续解析 CSS 和 Body。
5.  页面渲染第一帧时，遮罩已存在，且底色正确，用户看不到 FOUC。
6.  **Cleanup (关键)**: 页面加载完毕 (DOMContentLoaded) 100ms 后，执行 `removeGuard()`：
    -   移除 `js-loading` 类。
    -   **移除内联 `background-color` 和 `color`**。这是防止后续主题切换失败的关键，确保 CSS 变量能接管样式。

---

## 2. CMS 编辑器集成

### 2.1 Vditor 选择
我们选择了 `Vditor` 作为 Markdown 编辑器，因其支持即时渲染 (WYSIWYG) 和分屏预览。

### 2.2 资源隔离
为了不影响访客加载速度，编辑器资源仅在 `admin.html` 中引用。访客端使用轻量级的 `marked.js` 进行单纯的 HTML 渲染。

---

## 3. 模块间通信机制

在迁移到 ES6 后，我们移除了全局事件总线 (**Global Event Bus**)。

### 3.1 显式依赖与注入 (Dependency Injection)
除了基本的 `import`，我们在核心模块（尤其是 CMS）中广泛采用了依赖注入模式。
*   **做法**: 模块不再直接导入具体的状态单例，而是通过 `init(State, Render...)` 函数接收依赖。
*   **优势**: 极大降低了耦合度。例如，`Drag` 模块不需要知道 `State` 来自哪里，只要接口一致即可。这也使得 Literature 模块能够轻松复用 CMS 的组件。

### 3.2 观察者模式 (Observer Pattern)
对于复杂的状态同步（如音乐播放进度），我们使用轻量级的订阅发布模式，但限制在 `MusicPlayer` 类内部，不对外暴露全局事件。

---

## 4. 音乐播放器架构

### 4.1 PiP (Picture-in-Picture)
播放器不仅是一个底栏，还支持悬浮窗模式。实现上通过改变容器的 `position: fixed` 和层级来实现，而非浏览器原生的 Video PiP API（因为我们需要显示歌词和封面）。

### 4.2 状态持久化
播放状态（当前歌曲、进度、音量）实时写入 `LocalStorage`。用户刷新页面或跳转页面后，通过 `flash-guard.js` 或初始化脚本恢复状态，实现"无缝播放"的错觉。

---

## 5. 配置驱动架构 (Config-Driven Architecture)

为了最大化复用 CMS 逻辑（既支持笔记，也支持文学，甚至相册配置），我们建立了一个静态配置中心 `module-config.module.js`。

### 5.1 核心思想
**Code Once, Configure Everywhere**.
CMS 模块不包含任何硬编码的字符串（如 "Study Notes" 或 "Literature"）。它仅仅在运行时询问 Config："我现在的名字叫什么？我的图标是什么？我允许用户修改标签吗？"

### 5.2 全局可访问性
为了让这个配置对全站透明，它被挂载在 `window.MAERS.ModuleConfig`。这是经过严格审视的架构决策，因为它仅仅包含只读的静态数据（Metadata），不包含状态，因此没有并发风险，且极大地简化了深层组件获取配置的复杂度。

### 5.3 数据结构示例
```javascript
{
    literature: {
        title: 'Literature',
        allowTags: true,
        allowMove: true,
        dataFile: 'data/literature-tree.json'
    }
}
```
CMS 通过读取 `dataType` 属性（如 `current=literature`）来自动切换行为模式。

---

## 6. 基础设施服务模式 (Infrastructure Services)

我们在架构中严格区分了**业务逻辑**与**基础设施**。

### 6.1 定义
*   **业务逻辑 (Business Logic)**: 如相册渲染、音乐播放、笔记编辑。这些必须模块化，严格封装。
*   **基础设施 (Infrastructure)**: 如全局通知 (`Toast`)、主题状态 (`Theme`)。这些是“横切”整个应用的。

### 6.2 单例模式 (Singleton Pattern)
对于基础设施，我们采用挂载在 `window.MAERS` 下的单例模式。

**为什么不用 import?**
如果现在的 50+ 个业务文件都要报错，它们都需要写：
`import { Toast } from '../../shared/ui/toast.module.js'`
这产生了大量的样板代码 (Boilerplate) 和硬编码路径。

**设计决策**:
我们将 Toast 和 Theme 视为**运行时环境 (Runtime Environment)** 的一部分。就像浏览器自带 `alert()` 和 `console.log()` 一样，MAERS 运行环境自带 `MAERS.Toast.error()`。这种设计极大地提升了开发体验 (DX)，同时并未破坏业务逻辑的解耦。
